"""
Handlers for correction bolus strategies used during replay simulations.
"""

import numpy as np
import pandas as pd
from py_agata.risk import dynamic_risk #, static_risk

def standard_cib(
        glucose: np.ndarray,
        meal_announcement: np.ndarray,
        meal_type: np.ndarray,
        hypotreatments: np.ndarray,
        bolus: np.ndarray,
        basal: np.ndarray,
        time: np.ndarray,
        time_index: int,
        dss: object
        ) -> tuple[float, object]:
    """
    Implements the standard therapy correction bolus strategy: "take a correction bolus according to the standard formula 
    when in hyperglycemia and anyway after at least two hours from last bolus ".

    Parameters
    ----------
    glucose: np.ndarray
        An array vector as long the simulation length containing all the simulated glucose concentrations (mg/dl)
        up to time_index. The values after time_index should be ignored.
    meal_announcement: np.ndarray
        An array as long the simulation length containing all the cho intakes (g/min) up to time_index.
        It does not contain hypotreatment intakes. The values after time_index should be ignored.
    meal_type: np.ndarray
        An array of strings as long the simulation length containing the type of each meal.
        If blueprint is `single-meal`, labels can be:
            - `M`: main meal
            - `O`: other meal
        If blueprint is `multi-meal`, labels can be:
            - `B`: breakfast
            - `L`: lunch
            - `D`: dinner
            - `S`: snack
            - `H`: hypotreatment
        The values after time_index should be ignored.
    hypotreatments: np.ndarray
        An array vector as long the simulation length containing all the hypotreatment intakes (g/min) up to time_index.
        If the blueprint is single meal, hypotreatments will contain only the hypotreatments generated by this function
        during the simulation. If the blueprint is multi-meal, hypotreatments will ALSO contain the hypotreatments
        already present in the given data that labeled as such. The values after time_index should be ignored.
    bolus: np.ndarray
        An array vector as long the simulation length containing all the insulin boluses (U/min) up to time_index.
        The values after time_index should be ignored.
    basal: np.ndarray
        An array vector as long the simulation length containing all the insulin basal (U/min) up to time_index.
        The values after time_index should be ignored.
    time: np.ndarray
        An array vector as long the simulation length containing the time corresponding to the current step (hours)
        up to time_index. The values after time_index should be ignored.
    time_index: int
        The index corresponding to the previous simulation step of the replay simulation.
    dss: DSS
        An object that represents the hyperparameters of the integrated decision support system.

    Returns
    -------
    cb: float
        The correction bolus to administer at time[time_index + 1].
    dss: DSS
        An object that represents the hyperparameters of the integrated decision support system.
        dss is also an output since it contains correction_boluses_handler_params that beside being a
        dict that contains the parameters to pass to  this function, it also serves as memory area.
        It is possible to store values inside it and the corrects_above_250_handler function will be able
        to access to them in the next call of the function.

    Raises
    ------
    None

    See Also
    --------
    None

    Examples
    --------
    None
    """

    cb = 0

    # If glucose is higher than 180...
    if glucose[time_index] > 180:

        # ...and if there are no boluses in the last 120 minutes, then take a CB
        if time_index >= 120 and not np.any(bolus[(time_index - 120):time_index]):
            # compute iob            
            iob = compute_iob(bolus[:time_index])

            # get params
            cf = dss.bolus_calculator_handler_params['cf'] if 'cf' in dss.bolus_calculator_handler_params else 40
            gt = dss.bolus_calculator_handler_params['gt'] if 'gt' in dss.bolus_calculator_handler_params else 120
        
            cb = np.max([0, (glucose[time_index] - gt) / cf - iob])

    return cb, dss


def aleppo(
        glucose: np.ndarray,
        meal_announcement: np.ndarray,
        meal_type: np.ndarray,
        hypotreatments: np.ndarray,
        bolus: np.ndarray,
        basal: np.ndarray,
        time: np.ndarray,
        time_index: int,
        dss: object
        ) -> tuple[float, object]:
    """
    Implements the correction bolus strategy of Aleppo G. et al. in "A practical approach to using trend arrows on the Dexcom 
    G5 CGM system for the management of adults with diabetes". J Endocr Soc. (2017)

    Parameters
    ----------
    glucose: np.ndarray
        An array vector as long the simulation length containing all the simulated glucose concentrations (mg/dl)
        up to time_index. The values after time_index should be ignored.
    meal_announcement: np.ndarray
        An array as long the simulation length containing all the cho intakes (g/min) up to time_index.
        It does not contain hypotreatment intakes. The values after time_index should be ignored.
    meal_type: np.ndarray
        An array of strings as long the simulation length containing the type of each meal.
        If blueprint is `single-meal`, labels can be:
            - `M`: main meal
            - `O`: other meal
        If blueprint is `multi-meal`, labels can be:
            - `B`: breakfast
            - `L`: lunch
            - `D`: dinner
            - `S`: snack
            - `H`: hypotreatment
        The values after time_index should be ignored.
    hypotreatments: np.ndarray
        An array vector as long the simulation length containing all the hypotreatment intakes (g/min) up to time_index.
        If the blueprint is single meal, hypotreatments will contain only the hypotreatments generated by this function
        during the simulation. If the blueprint is multi-meal, hypotreatments will ALSO contain the hypotreatments
        already present in the given data that labeled as such. The values after time_index should be ignored.
    bolus: np.ndarray
        An array vector as long the simulation length containing all the insulin boluses (U/min) up to time_index.
        The values after time_index should be ignored.
    basal: np.ndarray
        An array vector as long the simulation length containing all the insulin basal (U/min) up to time_index.
        The values after time_index should be ignored.
    time: np.ndarray
        An array vector as long the simulation length containing the time corresponding to the current step (hours)
        up to time_index. The values after time_index should be ignored.
    time_index: int
        The index corresponding to the previous simulation step of the replay simulation.
    dss: DSS
        An object that represents the hyperparameters of the integrated decision support system.

    Returns
    -------
    cb: float
        The correction bolus to administer at time[time_index + 1].
    dss: DSS
        An object that represents the hyperparameters of the integrated decision support system.
        dss is also an output since it contains correction_boluses_handler_params that beside being a
        dict that contains the parameters to pass to  this function, it also serves as memory area.
        It is possible to store values inside it and the corrects_above_250_handler function will be able
        to access to them in the next call of the function.

    Raises
    ------
    None

    See Also
    --------
    None

    Examples
    --------
    None
    """
    cb = 0
    check_after_1h = dss.bolus_calculator_handler_params['check_after_1h'] if 'check_after_1h' in dss.bolus_calculator_handler_params else False
    
    # get last mealtime
    last_mealtime = get_last_mealtime(meal_announcement, meal_type, time_index)
    
    # if there has been a meal, trigger the algorithm
    if last_mealtime > 0:
        
        # get last mealtime bolus (if no bolus, consider when meal was announced)
        bolus_indices = np.where(bolus[:time_index] > 0)[0]

        if last_mealtime == -1 or len(bolus_indices) == 0:
            last_mealbolustime = last_mealtime
        else:
            nearby_boluses = bolus_indices[np.abs(bolus_indices - last_mealtime) <= 4]
            last_mealbolustime = nearby_boluses[-1] if len(nearby_boluses) > 0 else last_mealtime
            
        # get params
        cf = dss.bolus_calculator_handler_params.get('cf', 40)
        gt = dss.bolus_calculator_handler_params.get('gt', 120)
        
        # compute IOB
        iob = compute_iob(bolus[:time_index])
        
        # get arrow
        arrow = get_arrow((glucose[time_index] - glucose[time_index - 15]) / 15)
        
        if time_index - last_mealbolustime >= 2*60 and time_index - last_mealbolustime <= 4*60:
            # REPLACE-BG instuctions
            if check_after_1h and arrow > 2 and not np.any(bolus[(time_index - 1*60):time_index]):
                # ...give a bolus
                cb = np.max([0, (glucose[time_index] - gt) / cf - iob])
                dss.bolus_calculator_handler_params['check_after_1h'] = False
            
            if  glucose[time_index] > 250 and arrow > 2 and not np.any(bolus[(time_index - 2*60):time_index]):
                # ...give a bolus
                cb = np.max([0, (glucose[time_index] - gt) / cf - iob])
                dss.bolus_calculator_handler_params['check_after_1h'] = True
                
            elif glucose[time_index] > 150 and arrow > 1 and not np.any(bolus[(time_index - 2*60):time_index]):
                # ...give a bolus
                cb = np.max([0, (glucose[time_index] - gt) / cf - iob])
            
        elif time_index - last_mealbolustime > 4*60 and not np.any(bolus[(time_index - 2*60):time_index]):
            # get Aleppo's correction
            correction_trend = 0
            if arrow == -1:
                if cf < 25:
                    correction_trend = -2.5
                elif cf < 50:
                    correction_trend = -1.5
                elif cf < 75:
                    correction_trend = -1
                else:
                    correction_trend = -0.5
            elif arrow == -2:
                if cf < 25:
                    correction_trend = -3.5
                elif cf < 50:
                    correction_trend = -2.5
                elif cf < 75:
                    correction_trend = -1.5
                else:
                    correction_trend = -1
            elif arrow == -3:
                if cf < 25:
                    correction_trend = -4.5
                elif cf < 50:
                    correction_trend = -3.5
                elif cf < 75:
                    correction_trend = -2.5
                else:
                    correction_trend = -1.5
            elif arrow == 1:
                if cf < 25:
                    correction_trend = +2.5
                elif cf < 50:
                    correction_trend = +1.5
                elif cf < 75:
                    correction_trend = +1
                else:
                    correction_trend = +0.5
            elif arrow == 2:
                if cf < 25:
                    correction_trend = +3.5
                elif cf < 50:
                    correction_trend = +2.5
                elif cf < 75:
                    correction_trend = +1.5
                else:
                    correction_trend = +1
            elif arrow == 3:
                if cf < 25:
                    correction_trend = +4.5
                elif cf < 50:
                    correction_trend = +3.5
                elif cf < 75:
                    correction_trend = +2.5
                else:
                    correction_trend = +1.5
                    
            # ...give a bolus
            cb = np.max([0, (glucose[time_index] - gt) / cf - iob + correction_trend])
                
    return cb, dss
   

def drCORRECT(
        glucose: np.ndarray,
        meal_announcement: np.ndarray,
        meal_type: np.ndarray,
        hypotreatments: np.ndarray,
        bolus: np.ndarray,
        basal: np.ndarray,
        time: np.ndarray,
        time_index: int,
        dss: object
        ) -> tuple[float, object]:
    """
    Implements the correction bolus strategy of Pellizzari E. et al. in "drCORRECT: An algorithm for the preventive administration 
    of postprandial corrective insulin boluses in type 1 diabetes management.".  J Diabetes Sci Technol. (2023)

    Parameters
    ----------
    glucose: np.ndarray
        An array vector as long the simulation length containing all the simulated glucose concentrations (mg/dl)
        up to time_index. The values after time_index should be ignored.
    meal_announcement: np.ndarray
        An array as long the simulation length containing all the cho intakes (g/min) up to time_index.
        It does not contain hypotreatment intakes. The values after time_index should be ignored.
    meal_type: np.ndarray
        An array of strings as long the simulation length containing the type of each meal.
        If blueprint is `single-meal`, labels can be:
            - `M`: main meal
            - `O`: other meal
        If blueprint is `multi-meal`, labels can be:
            - `B`: breakfast
            - `L`: lunch
            - `D`: dinner
            - `S`: snack
            - `H`: hypotreatment
        The values after time_index should be ignored.
    hypotreatments: np.ndarray
        An array vector as long the simulation length containing all the hypotreatment intakes (g/min) up to time_index.
        If the blueprint is single meal, hypotreatments will contain only the hypotreatments generated by this function
        during the simulation. If the blueprint is multi-meal, hypotreatments will ALSO contain the hypotreatments
        already present in the given data that labeled as such. The values after time_index should be ignored.
    bolus: np.ndarray
        An array vector as long the simulation length containing all the insulin boluses (U/min) up to time_index.
        The values after time_index should be ignored.
    basal: np.ndarray
        An array vector as long the simulation length containing all the insulin basal (U/min) up to time_index.
        The values after time_index should be ignored.
    time: np.ndarray
        An array vector as long the simulation length containing the time corresponding to the current step (hours)
        up to time_index. The values after time_index should be ignored.
    time_index: int
        The index corresponding to the previous simulation step of the replay simulation.
    dss: DSS
        An object that represents the hyperparameters of the integrated decision support system.

    Returns
    -------
    cb: float
        The correction bolus to administer at time[time_index + 1].
    dss: DSS
        An object that represents the hyperparameters of the integrated decision support system.
        dss is also an output since it contains correction_boluses_handler_params that beside being a
        dict that contains the parameters to pass to  this function, it also serves as memory area.
        It is possible to store values inside it and the corrects_above_250_handler function will be able
        to access to them in the next call of the function.

    Raises
    ------
    None

    See Also
    --------
    None

    Examples
    --------
    None
    """
    cb = 0
    
    # get last mealtime and its label
    last_mealtime = get_last_mealtime(meal_announcement, meal_type, time_index) 
    if last_mealtime != dss.correction_boluses_handler_params.get('previous_mealtime', -1):
        # reset when a new main meal occurs
        dss.correction_boluses_handler_params['previous_mealtime'] = last_mealtime
        dss.correction_boluses_handler_params['first_bolus_after_meal'] = True
        
    t = pd.date_range(start=pd.Timestamp.today().normalize(),
                               periods=10, freq='5min')
    
    t_pers = dss.correction_boluses_handler_params.get('t_pers', 120)
    first_bolus_after_meal = dss.correction_boluses_handler_params.get('first_bolus_after_meal', True)

    dr_threshold = dss.correction_boluses_handler_params.get(
        'dr_threshold',
        dynamic_risk(
            pd.DataFrame({'t': t, 'glucose': np.ones(t.size) * 180})
        )[-1]
    )

    # if there has been a main meal, trigger the algorithm
    if last_mealtime > 0:
        
        # get last mealtime bolus (if no bolus, consider when meal was announced)
        bolus_indices = np.where(bolus[:time_index] > 0)[0]

        if last_mealtime == -1 or len(bolus_indices) == 0:
            last_mealbolustime = last_mealtime
        else:
            nearby_boluses = bolus_indices[np.abs(bolus_indices - last_mealtime) <= 4]
            last_mealbolustime = nearby_boluses[-1] if len(nearby_boluses) > 0 else last_mealtime
            
        if time_index - last_mealbolustime > t_pers and not np.any(bolus[(time_index - int(t_pers)):time_index]):
            # compute dr
            dr_vec = dynamic_risk(pd.DataFrame({'t': pd.date_range(start=pd.Timestamp.today().normalize(),
                            periods=len(glucose[:time_index]), freq='5min'), 'glucose': glucose[:time_index]}))
            
            if dr_vec[-1] > dr_threshold:
                # compute iob
                iob = compute_iob(bolus[:time_index])
                
                # get params
                cf = dss.bolus_calculator_handler_params.get('cf', 40)
                gt = dss.bolus_calculator_handler_params.get('gt', 120)
                
                if first_bolus_after_meal:
                    # ...give a bolus
                    cb = np.max([0, (glucose[time_index] - gt) / cf - iob])
                    dss.correction_boluses_handler_params['first_bolus_after_meal'] = False
                    
                else:
                    if np.diff(dr_vec)[-1] > 0:
                        # ...give a bolus
                        cb = np.max([0, (glucose[time_index] - gt) / cf - iob])
    
    return cb, dss


def get_last_mealtime(meal_announcement: np.ndarray, meal_type: np.ndarray, time_index: int) -> int:
    """
    Get the index of the last mealtime labeled as B, L or D before time_index.
    """
    
    meals = np.where(meal_announcement[:time_index] > 0)[0]
    if len(meals) == 0:
        return -1

    labels = meal_type[meals]

    mask_bld = np.isin(labels, ['B', 'L', 'D'])
    bld_meals = meals[mask_bld]

    if len(bld_meals) > 0:
        return bld_meals[-1]
    else:
        return -1


def compute_iob(bolus: np.ndarray) -> np.ndarray:
    """
    Compute insulin on board (IOB) from bolus array using a 6-hour action profile.
    """
    
    ts = 5

    k1 = 0.0173
    k2 = 0.0116
    k3 = 6.73

    iob_6h_curve = np.zeros(shape=(360,))

    for t in range(0, 360):
        iob_6h_curve[t] = 1 - 0.75 * ((- k3 / (k2 * (k1 - k2)) * (np.exp(-k2 * t / 0.75) - 1) + k3 / (
                    k1 * (k1 - k2)) * (np.exp(-k1 * t / 0.75) - 1)) / 2.4947e4)
    iob_6h_curve = iob_6h_curve[ts::ts]

    iob = np.convolve(bolus, iob_6h_curve)
    iob = iob[bolus.shape[0] - 1]
    
    return iob


def get_arrow(current_trend: float) -> int:
    """
    Scale the current trend (mg/dl/min) into an arrow value according to guidelines.
    """
    
    if abs(current_trend) <= 1:
        scaled_trend = 0
    elif 1 < current_trend < 2:
        scaled_trend = 1
    elif 2 <= current_trend <= 3:
        scaled_trend = 2
    elif current_trend >3:
        scaled_trend = 3
    elif -2 < current_trend < -1:
        scaled_trend = -1
    elif -3 <= current_trend <= -2:
        scaled_trend = -2
    elif current_trend < -3:
        scaled_trend = -3

    return scaled_trend